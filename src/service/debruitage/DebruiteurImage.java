package service.debruitage;

import java.util.ArrayList;
import java.util.List;

import model.acp.ResultatACP;
import model.acp.ResultatMoyCov;
import model.base.Img;
import model.base.Pixel;
import model.base.Position;
import model.base.Vecteur;
import model.patch.Fenetre;
import model.patch.ParametresFenetre;
import model.patch.ResultatPatch;
import model.patch.ResultatPatch.PairePatchPosition;
import model.patch.ResultatVecteur;
import service.acp.ProcesseurACP;
import service.bruit.BruiteurImage;
import service.evaluation.EvaluationrQualite;
import service.patch.GestionnairePatchs;
import service.seuillage.ProcesseurSeuillage;

public class DebruiteurImage {

	private BruiteurImage bruiteurImage;
	private GestionnairePatchs gestionnairePatchs;
	private ProcesseurACP processeurACP;
	private ProcesseurSeuillage processeurSeuillage;
	private EvaluationrQualite evaluationQualite;
	private final static int TAILLE_FENETRE_DEFAUT = 250;

	public DebruiteurImage() {
		this.bruiteurImage = new BruiteurImage();
		this.gestionnairePatchs = new GestionnairePatchs();
		this.processeurACP = new ProcesseurACP();
		this.processeurSeuillage = new ProcesseurSeuillage();
		this.evaluationQualite = new EvaluationrQualite();

	}

	private Img debruiterGlobal(Img xB, String typeSeuil, String fonctionSeuillage, double sigma, int taillePatch) {

		System.out.println("üìä MODE GLOBAL - Traitement de l'image enti√®re");

		// Extraction des patchs et leur transformation en vecteurs
		System.out.println("‚è≥ √âtape 1/8 : Extraction des patchs...");
		ResultatPatch resPatchs = gestionnairePatchs.extractPatchs(xB, taillePatch);
		System.out.println("‚úÖ Extraction de " + resPatchs.taille() + " patchs r√©ussie");

		List<Position> positionsOriginales = new ArrayList<>();
		for (PairePatchPosition p : resPatchs) {
			positionsOriginales.add(p.getPosition());
		}

		System.out.println("‚è≥ √âtape 2/8 : Vectorisation des patchs...");
		ResultatVecteur resVecteurs = gestionnairePatchs.vectorPatchs(resPatchs);
		System.out.println("‚úÖ Vectorisation r√©ussie");

		try {
			// √âtape 1: Calcul de l'ACP
			System.out.println("‚è≥ √âtape 3/8 : Calcul de l'ACP...");
			ResultatACP resACP = processeurACP.acp(resVecteurs);
			System.out.println("‚úÖ Analyse en composantes principales r√©ussie");

			// √âtape 2: R√©cup√©ration des r√©sultats MoyCov
			System.out.println("‚è≥ √âtape 4/8 : Calcul des statistiques...");
			ResultatMoyCov resMoyCov = processeurACP.moyCov(resVecteurs);
			System.out.println("‚úÖ Calcul des statistiques r√©ussi");

			// √âtape 3: Projection des vecteurs
			System.out.println("‚è≥ √âtape 5/8 : Projection des vecteurs...");
			ResultatVecteur vecteursPropresRV = gestionnairePatchs
					.matriceToResultatVecteur(resACP.getVecteursPropres());

			ResultatVecteur vecteursProj = processeurACP.proj(vecteursPropresRV, resMoyCov.getVecteursCenters());
			System.out.println("‚úÖ Projection r√©ussie");

			// √âtape 4: R√©cup√©ration des positions
			ResultatVecteur vecteursProjRV = new ResultatVecteur();
			for (int i = 0; i < vecteursProj.taille(); i++) {
				// Utiliser les positions originales au lieu des positions de resMoyCov
				Position position = i < positionsOriginales.size() ? positionsOriginales.get(i) : new Position(0, 0);
				vecteursProjRV.ajouterVecteur(vecteursProj.getVecteurs().get(i), position);
			}

			// √âtape 5: Seuillage des coefficients
			System.out.println("‚è≥ √âtape 6/8 : Seuillage des coefficients...");
			ResultatVecteur vecteursSeuil = processeurSeuillage.seuillage(vecteursProjRV, typeSeuil, fonctionSeuillage,
					sigma, xB, resMoyCov.getMatriceCovariance());
			System.out.println("‚úÖ Seuillage r√©ussi");

			// √âtape 6: Reconstruction
			System.out.println("‚è≥ √âtape 7/8 : Reconstruction des vecteurs...");
			ResultatVecteur vecteursReconstruits = processeurACP.reconstructionDepuisCoefficients(vecteursSeuil,
					resACP.getVecteursPropres(), resACP.getVecteurMoyen());
			System.out.println("‚úÖ Reconstruction des vecteurs r√©ussie");

			// √âtape 7: Conversion en patchs
			System.out.println("‚è≥ √âtape 8/8 : Reconstruction de l'image...");
			ResultatPatch patchsReconstruits = gestionnairePatchs
					.transformerVecteursEnResultatPatch(vecteursReconstruits);

			// √âtape 8: Reconstruction finale
			Img imgReconstruite = gestionnairePatchs.reconstructionPatchs(patchsReconstruits, xB.getHauteur(),
					xB.getLargeur(), xB);
			System.out.println("\nüéâ D√âBRUITAGE GLOBAL TERMIN√â AVEC SUCC√àS üéâ");

			return imgReconstruite;
		} catch (Exception e) {
			System.err.println("ERREUR lors du d√©bruitage: " + e.getMessage());
			e.printStackTrace();
			return xB; // En cas d'erreur, retourne l'image bruit√©e
		}
	}

	private Img debruiterLocal(Img xB, String typeSeuil, String fonctionSeuillage, double sigma, int taillePatch) {

		System.out.println("üß© MODE LOCAL - Traitement par fen√™tres");
		System.out.println("‚è≥ √âtape 1/5 : Calcul des param√®tres de fen√™trage...");
		// Calcul des param√®tres de fen√™trage
		ParametresFenetre pF = ParametresFenetre.calculerParametresFenetre(xB.getLargeur(), xB.getHauteur(),
				TAILLE_FENETRE_DEFAUT);

		System.out.println("\n ‚öôÔ∏è  Param√®tres de fen√™trage: ‚öôÔ∏è ");
		System.out.println("  Dimensions de l'image: " + xB.getLargeur() + "√ó" + xB.getHauteur());
		System.out.println("  Taille de fen√™tre: " + pF.getTailleFenetreCalculee());
		System.out.println("  Grille: " + pF.getNombreFenetresX() + "√ó" + pF.getNombreFenetresY() + " fen√™tres");
		System.out.println(
				"  Chevauchement: X=" + pF.getChevauchementCombineX() + ", Y=" + pF.getChevauchementCombineY());

		System.out.println("‚è≥ √âtape 2/5 : D√©coupage de l'image en fen√™tres...");
		// D√©coupage de l'image en fen√™tres
		List<Fenetre> imagettesList = gestionnairePatchs.decoupageImage(xB, pF);
		System.out.println("‚úÖ D√©coupage en " + imagettesList.size() + " fen√™tres r√©ussi");

		System.out.println("‚è≥ √âtape 3/5 : Initialisation de l'image r√©sultat...");
		// Initialisation de l'image r√©sultat
		Pixel[][] xRPixels = new Pixel[xB.getHauteur()][xB.getLargeur()];
		for (int i = 0; i < xB.getHauteur(); i++) {
			for (int j = 0; j < xB.getLargeur(); j++) {
				xRPixels[i][j] = new Pixel(0);
			}
		}
		System.out.println("‚úÖ Initialisation r√©ussie");

		// Compteur de progression
		int fenetreTraitee = 0;
		System.out.println("‚è≥ √âtape 4/5 : Traitement de chaque fen√™tre...");
		// Traitement de chaque fen√™tre
		for (Fenetre f : imagettesList) {
			fenetreTraitee++;

			// Extraction des patchs et conversion en vecteurs
			ResultatPatch resPatchs = gestionnairePatchs.extractPatchs(f.getImage(), taillePatch);

			List<Position> positionsOriginales = new ArrayList<>();
			for (PairePatchPosition p : resPatchs) {
				positionsOriginales.add(p.getPosition());
			}

			ResultatVecteur resVecteurs = gestionnairePatchs.vectorPatchs(resPatchs);

			try {
				// Analyse ACP sur la fen√™tre
				ResultatACP resACP = processeurACP.acp(resVecteurs);
				ResultatMoyCov resMoyCov = processeurACP.moyCov(resVecteurs);

				// Conversion des vecteurs propres
				ResultatVecteur vecteursPropresRV = gestionnairePatchs
						.matriceToResultatVecteur(resACP.getVecteursPropres());

				// Projection, seuillage et reconstruction
				ResultatVecteur vecteursProj = processeurACP.proj(vecteursPropresRV, resMoyCov.getVecteursCenters());

				ResultatVecteur vecteursProjRV = new ResultatVecteur();
				for (int i = 0; i < vecteursProj.taille(); i++) {
					Position position = i < positionsOriginales.size() ? positionsOriginales.get(i)
							: new Position(0, 0);
					vecteursProjRV.ajouterVecteur(vecteursProj.getVecteurs().get(i), position);
				}

				ResultatVecteur vecteursSeuil = processeurSeuillage.seuillage(vecteursProjRV, typeSeuil,
						fonctionSeuillage, sigma, f.getImage(), resMoyCov.getMatriceCovariance());

				ResultatVecteur vecteursReconstruits = processeurACP.reconstructionDepuisCoefficients(vecteursSeuil,
						resACP.getVecteursPropres(), resACP.getVecteurMoyen());

				ResultatPatch patchsReconstruits = gestionnairePatchs
						.transformerVecteursEnResultatPatch(vecteursReconstruits);

				// Reconstruction de l'image pour cette fen√™tre
				Img nfImg = gestionnairePatchs.reconstructionPatchs(patchsReconstruits, f.getImage().getHauteur(),
						f.getImage().getLargeur(), xB);

				// Fusion des r√©sultats dans l'image globale
				Pixel[][] nfPixels = nfImg.getPixels();

				for (int i = 0; i < nfPixels.length; i++) {
					for (int j = 0; j < nfPixels[0].length; j++) {
						int posY = i + f.getPosition().getI();
						int posX = j + f.getPosition().getJ();

						if (posY < xB.getHauteur() && posX < xB.getLargeur()) {
							Pixel pixelGlobal = xRPixels[posY][posX];
							pixelGlobal.setValeur(pixelGlobal.getValeur() + nfPixels[i][j].getValeur());
							pixelGlobal.setNbChevauchement(pixelGlobal.getNbChevauchement() + 1);
						}
					}
				}

			} catch (Exception e) {
				System.err
						.println("  ERREUR lors du traitement de la fen√™tre " + fenetreTraitee + ": " + e.getMessage());
				e.printStackTrace();
			}
		}

		System.out.println("\n‚úÖ Traitement de toutes les fen√™tres r√©ussi");

		System.out.println("‚è≥ √âtape 5/5 : Normalisation et finalisation...");
		for (int i = 0; i < xRPixels.length; i++) {
			for (int j = 0; j < xRPixels[0].length; j++) {
				if (xRPixels[i][j].getNbChevauchement() > 0) {
					double valeurNormalisee = xRPixels[i][j].getValeur() / (double) xRPixels[i][j].getNbChevauchement();
					int valeurFinale = (int) Math.min(255, Math.max(0, Math.round(valeurNormalisee)));
					xRPixels[i][j].setValeur(valeurFinale);
				} else {
					xRPixels[i][j].setValeur(xB.getPixel(i, j).getValeur());
				}
			}
		}

		System.out.println("‚úÖ Normalisation r√©ussie");
		System.out.println("\nüéâ D√âBRUITAGE LOCAL TERMIN√â AVEC SUCC√àS üéâ");

		return new Img(xRPixels);
	}

	/**
	 * Fonction principal d√©bruitage ACP + seuillage (mode global ou local) avec r√©sultats.
	 * 
	 * @param xB                Image bruit√©e √† d√©bruiter
	 * @param typeSeuil         Type de seuil ("VisuShrink" ou "BayesShrink")
	 * @param fonctionSeuillage Fonction de seuillage ("Dur" ou "Doux")
	 * @param sigma             √âcart-type estim√© du bruit
	 * @param taillePatch       Taille des patchs pour l'analyse
	 * @param modeLocal         Si true, traitement par fen√™tres locales; sinon
	 *                          traitement global
	 * @return Image d√©bruit√©e
	 */
	public Img imageDen(Img xB, String typeSeuil, String fonctionSeuillage, double sigma, int taillePatch,
			boolean modeLocal) {
		System.out.println("\nüîç D√âMARRAGE DU D√âBRUITAGE D'IMAGE üîç");
		System.out.println("‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ");
		System.out.println("üõ†Ô∏è  Mode: " + (modeLocal ? "LOCAL" : "GLOBAL"));
		System.out.println("üõ†Ô∏è  Type de seuil: " + typeSeuil);
		System.out.println("üõ†Ô∏è  Fonction: " + fonctionSeuillage);
		System.out.println("üõ†Ô∏è  Sigma: " + sigma);
		System.out.println("üõ†Ô∏è  Taille des patchs: " + taillePatch + "√ó" + taillePatch);
		System.out.println("‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n");

		Img imgResult = modeLocal ? debruiterLocal(xB, typeSeuil, fonctionSeuillage, sigma, taillePatch)
				: debruiterGlobal(xB, typeSeuil, fonctionSeuillage, sigma, taillePatch);

		

		return imgResult;
	}

}
